import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar

plugins {
    id 'java-library'
    id 'maven-publish'
    id 'com.gradleup.shadow' version "${shadow_version}"
    id 'net.linguica.maven-settings' version "${maven_settings_version}"
    id "de.undercouch.download" version "${gradle_download_task_version}"
}

base {
    archivesName = 'rnnoise4j'
}
group = 'de.maxhenkel.rnnoise4j'
version = library_version

java {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
    toolchain.languageVersion = JavaLanguageVersion.of(java_toolchain_version)
    withSourcesJar()
    withJavadocJar()
}

tasks.named('sourcesJar', Jar) {
    exclude 'natives/**'
    exclude '**/*.bin'
}

def generatedResourcesDir = layout.buildDirectory.dir("generated-resources")

sourceSets {
    main {
        java {
            srcDir 'src/main/jni'
        }
        resources {
            srcDir generatedResourcesDir
        }
    }
    ffm {
        java {
            srcDir 'src/main/ffm'
        }
        resources {
            srcDir generatedResourcesDir
        }
        compileClasspath += sourceSets.main.output
        runtimeClasspath += sourceSets.main.output
    }
}

repositories {
    mavenCentral()
    maven { url = 'https://maven.maxhenkel.de/repository/public' }
}

def ffmClassPath = layout.buildDirectory.dir("classes/java/ffm")

tasks.named('compileJava', JavaCompile).configure {
    javaCompiler = javaToolchains.compilerFor {
        languageVersion = JavaLanguageVersion.of(java_toolchain_version)
    }
    options.release = 8
    options.encoding = 'UTF-8'
}

tasks.named(sourceSets.ffm.compileJavaTaskName, JavaCompile).configure {
    javaCompiler = javaToolchains.compilerFor {
        languageVersion = JavaLanguageVersion.of(java_toolchain_version)
    }
    options.release = 22
    sourceCompatibility = JavaVersion.VERSION_22
    targetCompatibility = JavaVersion.VERSION_22
}

tasks.named('shadowJar', ShadowJar).configure { sh ->
    dependsOn tasks.named(sourceSets.ffm.compileJavaTaskName)
    manifest {
        attributes 'Multi-Release': 'true'
    }
    from(sourceSets.main.output)

    into("META-INF/versions/22") {
        from(ffmClassPath)
    }
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

tasks.named('clean').configure {
    doFirst {
        delete ffmClassPath
    }
}

tasks.register('testJNI', Test) {
    group = 'verification'
    useJUnitPlatform()
    javaLauncher = javaToolchains.launcherFor {
        languageVersion = JavaLanguageVersion.of(8)
    }
    testClassesDirs = sourceSets.test.output.classesDirs
    classpath = sourceSets.test.runtimeClasspath
}

tasks.register('testFFM', Test) {
    group = 'verification'
    useJUnitPlatform()
    dependsOn tasks.named(sourceSets.ffm.compileJavaTaskName)

    javaLauncher = javaToolchains.launcherFor {
        languageVersion = JavaLanguageVersion.of(java_toolchain_version)
    }

    testClassesDirs = sourceSets.test.output.classesDirs
    classpath = files(ffmClassPath, sourceSets.test.runtimeClasspath)
}

tasks.register('runBenchmarksFFM', JavaExec) {
    group = 'verification'

    dependsOn tasks.named(sourceSets.ffm.compileJavaTaskName)

    javaLauncher = javaToolchains.launcherFor {
        languageVersion = JavaLanguageVersion.of(java_toolchain_version)
    }

    mainClass.set('de.maxhenkel.rnnoise4j.Benchmarks')

    classpath = files(ffmClassPath, sourceSets.test.runtimeClasspath)
}

tasks.register('runBenchmarksJNI', JavaExec) {
    group = 'verification'

    javaLauncher = javaToolchains.launcherFor {
        languageVersion = JavaLanguageVersion.of(8)
    }

    mainClass.set('de.maxhenkel.rnnoise4j.Benchmarks')

    classpath = sourceSets.test.runtimeClasspath
}

configurations {
    ffmImplementation.extendsFrom implementation
}

dependencies {
    compileOnly 'com.google.code.findbugs:jsr305:3.0.2'

    implementation "de.maxhenkel.native-utils:native-utils:${nativeutils_version}"

    testImplementation platform("org.junit:junit-bom:${junit_version}")
    testImplementation 'org.junit.jupiter:junit-jupiter'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'
    testImplementation 'org.junit.platform:junit-platform-launcher'
}

test {
    useJUnitPlatform()
}

shadowJar {
    archiveClassifier = ''
    relocate("de.maxhenkel.nativeutils", "de.maxhenkel.rnnoise4j")
}
tasks.assemble.dependsOn tasks.shadowJar

publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java
            pom {
                name = 'RNNoise4J'
                description = 'RNNoise Wrapper for Java'
                url = 'https://maxhenkel.de'
            }
        }
    }
    repositories {
        maven {
            name = 'henkelmax.public'
            url = uri('https://maven.maxhenkel.de/repository/public')
        }
    }
}

tasks.register("fetchWeights", Download) {
    src "https://github.com/henkelmax/rnnoise-weights/releases/download/v0.2/weights_blob_small.bin"
    dest generatedResourcesDir.get().file("rnnoise/weights_blob.bin")
    onlyIfModified true
}

tasks.named("processResources") {
    dependsOn("fetchWeights")
}

def platforms = [
        [
                name  : 'windows-x64',
                file  : 'zig-x86_64-windows-gnu.cmake',
                res   : 'windows-x64',
                libExt: 'dll'
        ],
        [
                name  : 'windows-arm64',
                file  : 'zig-aarch64-windows-gnu.cmake',
                res   : 'windows-aarch64',
                libExt: 'dll'
        ],
        [
                name  : 'linux-x64',
                file  : 'zig-x86_64-linux-gnu.cmake',
                res   : 'linux-x64',
                libExt: 'so'
        ],
        [
                name  : 'linux-arm64',
                file  : 'zig-aarch64-linux-gnu.cmake',
                res   : 'linux-aarch64',
                libExt: 'so'
        ],
        [
                name  : 'macos-x64',
                file  : 'zig-x86_64-macos.cmake',
                res   : 'mac-x64',
                libExt: 'dylib'
        ],
        [
                name  : 'macos-arm64',
                file  : 'zig-aarch64-macos.cmake',
                res   : 'mac-aarch64',
                libExt: 'dylib'
        ],
]

platforms.each { target ->
    def safeName = target.name.capitalize().replace('-', '')
    def configureTask = "configureNatives${safeName}"
    def buildTask = "buildNatives${safeName}"
    def copyTask = "copyNatives${safeName}"

    def cmakeListsPath = "../../CMakeLists.txt"
    def cmakePlatformPath = "../../cmake/${target.file}"
    def buildDir = layout.projectDirectory.dir("native/build/${target.res}")
    def resourceDir = generatedResourcesDir.get().dir("natives/${target.res}")
    def cSourcesDir = layout.projectDirectory.dir('native/src')
    def outputName = "librnnoise4j.${target.libExt}"

    tasks.register(configureTask, Exec) {
        group = 'natives'
        description = "CMake configure for ${target.name}"
        workingDir = buildDir

        inputs.file(buildDir.file(cmakeListsPath))
        inputs.file(buildDir.file(cmakePlatformPath))
        inputs.dir(cSourcesDir)
        outputs.dir(buildDir)

        doFirst {
            def dir = buildDir.asFile
            if (dir.exists()) {
                logger.lifecycle("Cleaning ${dir}")
                project.delete(fileTree(dir: dir))
            }
            dir.mkdirs()
        }

        commandLine 'cmake',
                "-DCMAKE_TOOLCHAIN_FILE=${cmakePlatformPath}",
                '-DCMAKE_BUILD_TYPE=Release',
                '-G', 'Ninja',
                '../..'
    }

    tasks.register(buildTask, Exec) {
        group = 'natives'
        description = "Build natives for ${target.name}"
        workingDir = buildDir
        dependsOn configureTask

        inputs.dir(buildDir)
        outputs.dir(buildDir)

        commandLine 'cmake', '--build', '.', '--config', 'Release'
    }

    tasks.register(copyTask, Copy) {
        group = 'natives'
        description = "Copy ${target.name} natives into resources"
        dependsOn buildTask

        from buildDir.file(outputName)
        into resourceDir
    }
}

tasks.register('buildAndCopyAllNatives') {
    group = 'natives'
    description = 'Build & copy all native libraries for every platform/arch'
    dependsOn platforms.collect { "copyNatives${it.name.capitalize().replace('-', '')}" }
}

tasks.named('processResources') {
    dependsOn 'buildAndCopyAllNatives'
}

tasks.named("clean", Delete).configure {
    delete("native/build")
}
